---
  title: "Variography using R/gstlearn - Correction"
  author: "Thomas Romary, Fabien Ors, Lucia Clarotto, Mike Pereira, and Xavier Freulon"
  date: "Option Géostatistique 2024"
  output:
  pdf_document:
  number_sections: yes
  toc: yes
  editor_options: 
    chunk_output_type: console
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())

library(minigst)
```

# Preamble


```{r loading_gstlearn}
OptCst_defineByKey("ASP",0)
```


## Loading the Meuse dataset

```{r loading_data_set}
library(sp) # load library
data(meuse) # load data
data(meuse.grid) # load target grid
```


Create the data Db

```{r loading_in_Db}

## Create Db from dataframe
data=dfToDb(meuse,coordnames = c("x","y"))

## Add log concentrations
var_name = c( "cadmium", "copper", "lead", "zinc")
addVarToDb(data,var=log(meuse[,var_name]),vname = paste0("log_",var_name))

# Plot the data

dbplot_point(data,size="log_cadmium",sizeRange = c(0.1,3), pointColor = "red",
             xlab = "Easting (m)", ylab = "Northing (m)", title = "Cadmium")

```

Create the target (grid) Db

```{r create the target (grid dB)}
target = dfToDbGrid(meuse.grid,coordnames = c('x','y'))

# Plot the distance covariate (see universal kriging)

dbplot_grid(target, color='dist',title='Distance to the river')
```

# Kriging using R

## Model of variogram

1. With gstlearn, adjust an isotropic variogram model (impose an **exponential structure**) and extract its parameters (scale and sill).

```{r}
# experimental variogram
varioexp_iso = vario_exp(data,vname="log_cadmium",nlag=20, dlag=100.)

# fitting the model with the selected basic structures
struct_names=c("EXPONENTIAL")
model_iso=model_fit(varioexp_iso,struct=struct_names)
# display of the model
model_iso$display()

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_iso,model = model_iso,pairDisplay = "size",
           title="Model adjustment for log cadmium")

## Extract scale (à warper ?)

Range = model_iso$getCova(0)$getRanges()[1]

## Extract sill

Sill = model_iso$getCova(0)$getSill(0,0)

```

2. Implement a function to evaluate the covariance model for a given lag using the parameters previsouly extracted.

```{r}
## Covariance function
modelCov_exp <- function(h,range,sill){
  # returns the value of exponential covariance at lag h
  sill*exp(-(h/range))
}
```

## Simple kriging

1. Implement the simple kriging estimate and the kriging error standard deviation (on a unique neighborhood) to estimate the concentration of cadmium on the points defined in `data`. 

a) Build a matrix containing the data (grid and concentration values) and compute the mean used for simple kriging.

```{r}
## Data matrix

DbCadmium = meuse[,1:3]
DbCadmium$cadmium = log(DbCadmium$cadmium)

DbCadmium

## Mean of observations

meanCadmium = mean(DbCadmium[,3])

meanCadmium

```

b) Build the matrices of covariance values between pairs of data points and between data points and target points. NB : the range extracted from the gstlearn adjustment is the practical range; the theoretical range is called "scale".

```{r}
## Convert Range into scale parameter

Range = Range/-log(.05)

## Distance matrix between every pair of observation points

distDbCadmium = sqrt(outer(DbCadmium$x, DbCadmium$x, "-")^2 + outer(DbCadmium$y, DbCadmium$y, "-")^2)

## Corresponding covariance matrix

covDbCadmium  = modelCov_exp(distDbCadmium, range = Range, sill = Sill)

## Distance matrix between every pair  (observation point, target point)

distTargetGrid = sqrt(outer(DbCadmium$x, meuse.grid$x, "-")^2 + outer(DbCadmium$y, meuse.grid$y, "-")^2)

## Corresponding covariance matrix

covTargetGrid = modelCov_exp(distTargetGrid, range = Range, sill = Sill)

```

c) Build the kriging estimates and compute the standard deviation of kriging error.

```{r}
## Compute simple kriging weights

SKweights = solve(covDbCadmium, covTargetGrid)

## Simple kriging estimate

SKestim = meanCadmium + t(SKweights) %*% (DbCadmium$cadmium - meanCadmium)

## Kriging variance
SKvar = Sill - apply(SKweights * covTargetGrid, 2, sum)
#SKvar=cov-diag(t(SKweights)%*%covTargetGrid) # equivalent to above but numerically less efficient

## Kriging standard deviation
SKsd = sqrt(SKvar)

```

2. Plot the maps of the estimated concentration and the standard deviation of kriging error. Use either the function `bubblePlot()` from the library `fields`.

```{r}
library(fields)

## Kriging plot using bubblePlot

bubblePlot(meuse.grid$x, meuse.grid$y, SKestim, asp=1)#, nx=length(unique(meuse.grid$x)), ny=length(meuse.grid$y))
points(DbCadmium$x,DbCadmium$y,pch=19,cex=0.25)


## Kriging stdev plot using bubblePlot
bubblePlot(meuse.grid$x, meuse.grid$y, SKsd, asp=1)
points(DbCadmium$x,DbCadmium$y,pch=19,cex=0.25)

```

# Kriging using gstlearn

## Simple kriging and ordinary kriging (unique neighborhood)

1. Adjust an anisotropic variogram model (see TP_vario).

```{r}
# experimental variogram
varioexp_aniso = vario_exp(data,vname="log_cadmium",dir=c(0,45,90,135),nlag=20, dlag=100.)

# fitting the model
model_aniso=model_fit(varioexp_aniso,struct=struct_names)
# display of the model
model_aniso$display() ## look at the anisotropic matrices

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_aniso,model = model_aniso,pairDisplay = "size",
           title="Model adjustment for cadmium")

```

2. Simple kriging: use model to compute the simple kriging predictor of the cadmium concentration, using the function `kriging`. Plot the results (prediction and standard deviation of kriging error) and compare them to the results obtained in the previous part (using `R` only).

```{r}
## Simple kriging using gstlearn

target = kriging_uni(data, target, vname = "log_cadmium", model = model_aniso, type = "simple", prefix = "SK", mean = meanCadmium, neighborhood = "unique", std = TRUE)


## Plot kriging estimate
dbplot_grid(target, color='SK.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(target, color='SK.log_cadmium.stdev',title='log cadmium prediction standard deviation')

```

3. Ordinary kriging: use the same neighborhood and model to compute ordinary kriging estimate.

```{r}
target = kriging_uni(data, target, vname = "log_cadmium", model = model_aniso, type = "ordinary", prefix = "OK", neighborhood = "unique", std = TRUE)

## Plot kriging estimate
dbplot_grid(target, color='OK.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(target, color='OK.log_cadmium.stdev',title='log cadmium prediction standard deviation')

```

## Comparison of the results

1. Cross validation : For each observation location x_i, compute the kriging prediction at x_i when using all the observations except the one located at x_i. The cross-validation error at x_i is then defined as the difference between this prediction and the actual observed value at x_i.

Cross-validation is done by the gstlearn function xvalid. This function returns a db containing the same variables as the input db + two new variables: One variable (with name ending with .esterr) containing the cross-validation errors, and one variable (with name ending with .stderr) containing the cross-validation errors normalized by the kriging standard deviation.


```{r}

## Cross-validation for simple kriging

err = xvalidation(data, vname = "log_cadmium", model=model_aniso, type = "simple",prefix ="SK", mean = meanCadmium, neighborhood = "unique", std = TRUE)

plot_hist(data,vname="*esterr*",nbin=30,color="blue",xlab="Estimation Errors", title="Cross-Validation")

## Print some statistics about the cross-validation errors
print(c("Mean cross-validation error:",mean(data[,"*esterr*"], na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(data[,"*esterr*"]^2, na.rm=TRUE)))
print(c("Mean squared standardized error:",mean(data[,"*stderr*"]^2, na.rm=TRUE)))

dbplot_grid(target,color = "SK*estim")
dbplot_point(data,size = "*esterr*", add=T)

## Cross-validation for ordinary kriging

#...

```

2. Correlation plot: to compare the results of both estimator, you can also use the function `plot.correlation`. For example, plot the correlation between predictions on the one hand, and standard deviations of error on the second hand obtained with simple kriging (`SK`) and ordinary kriging (`OK`).

```{r}
## Correlation plot Simple Kriging VS Ordinary Kriging: Predictions

plot_correlation(target,vnamex="OK.log_cadmium.estim",vnamey="SK.log_cadmium.estim", title="Estimation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")
                     
## Correlation plot Simple Kriging VS Ordinary Kriging: Standard deviations

plot_correlation(target,vnamex="OK.log_cadmium.stdev",vnamey="SK.log_cadmium.stdev", title="Estimation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")

```

3. Split randomly the dataset into a training and a validation datasets. Compute the mean squared error at the validation locations.

## Kriging with moving neighborhood

Up until now, we only considered kriging with a unique neighborhood. To work with a moving neighborhood, we first need to define it by creating "neighborhood" object describing its characteristics. This is done using the `neighborhood` parameter of the 'kriging_uni' funcion. We can specify:

* a neighborhood radius (argument `radius`, default=1.234e30): note that the default radius value is taken very large so that the neighborhood radius can basically be seen as infinite if the argument is not set by the user
* the minimum and maximum number of data points (within the specified radius) that should be included in the neighborhood (respectively through the arguments `nmini` and `nmaxi`): for a given target point, if the number of data points within the neighborhood radius is smaller that the specified minimum, then no prediction is performed at this target (it is set to undefined)

For instance, to design a small Moving Neighborhood with only 1 sample per neighborhood (irregardless of its distance to the target point), we use the following command:

```{r}
neigh = c(nmini=1, nmaxi=1, radius = 150)
```

2. Use that neighborhood and the anistropic model adjusted previously to compute ordinary kriging estimate and standard deviation of kriging error (set `prefix="OK_mov"`). Plot the results.

```{r}
## Ordinary kriging

target = kriging_uni(data, target, vname = "log_cadmium", model = model_aniso, type = "ordinary", prefix = "OK_mov",neighborhood = neigh, std = TRUE)

## Plot kriging estimate
dbplot_grid(target, color='OK_mov.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(target, color='OK_mov.log_cadmium.stdev',title='log cadmium prediction standard deviation')
```

3. Compare the results obtained with a unique neighborhood and a moving neighborhood (`OK` and `OK_mov`) with cross validation and correlation plot.

```{r}
## Cross-validation for Ordinary kriging with moving neigborhood

err = xvalidation(data, vname = "log_cadmium", model=model_aniso, type = "ordinary", prefix="OK_mov", mean = meanCadmium, neighborhood = "unique", std = TRUE)

plot_hist(data,vname="Xvalid_OK_mov*esterr",nbin=30,color="blue",xlab="Estimation Errors", title="Cross-Validation")

## Print some statistics about the cross-validation errors
print(c("Mean cross-validation error:",mean(data[,"Xvalid_OK_mov*esterr"], na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(data[,"Xvalid_OK_mov*esterr"]^2, na.rm=TRUE)))
print(c("Mean squared standardized error:",mean(data[,"Xvalid_OK_mov*stderr*"]^2, na.rm=TRUE)))

dbplot_grid(target,color = "OK_mov*estim")
dbplot_point(data,size = "Xvalid_OK_mov*esterr", add=T)

## Correlation plot Ordinary Kriging unique neigborhood VS moving neigborhood: Predictions

plot_correlation(target,vnamex="OK.log_cadmium.estim",vnamey="OK_mov.log_cadmium.estim", title="Estimation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")
                     
## Correlation plot Simple Kriging VS Ordinary Kriging: Standard deviations

plot_correlation(target,vnamex="OK.log_cadmium.stdev",vnamey="OK_mov.log_cadmium.stdev", title="Estimation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")

```

Bonus question: try with other neighborhoods and compare the results.

## Change of model

Change the models (impose other structures) and compare the performance of kriging estimates (be attentive to the changes in standard deviation of kriging error).

```{r}
## Define model

struct_names=c("NUGGET","EXPONENTIAL")
# fitting the model
model_aniso=model_fit(varioexp_aniso,struct=struct_names)
# display of the model
model_aniso$display() ## look at the anisotropic matrices

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_aniso,model = model_aniso,pairDisplay = "size",
           title="Model adjustment for cadmium")

## ....

```



