---
  title: "Kriging using (mini)gstlearn - Correction"
  author: "Emilie Chautru, Mike Pereira, and Thomas Romary"
  date: "Option GÃ©ostatistique 2024"
  output:
  pdf_document:
  number_sections: yes
  toc: yes
  editor_options: 
    chunk_output_type: console
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())

library(minigst)
library(fields)
```

# Preamble


```{r loading_gstlearn}
OptCst_defineByKey("ASP",0)
```


## Loading the Meuse dataset

We start by loading the data from the `sp` package. We load two data frames:

  * `meuse` is a R dataframe containing metal concentrations measured along the Meuse river in France. It contains the following variables:
    -   **x** and **y**: easting and northing (m) coordinates
    -   **cadmium**, **copper**, **lead**, **zinc**: topsoil heavy metal concentrations (ppm) (NB: obtained from composite samples **15m x 15m**)
    -   **elev**: relative elevation above the river (m)
    -   **dist**: distance to the river (normalized between 0 and 1)
    -   **om**, **soil**, **lime**: soil characteristics (content of organic matter, type of soil, presence of lime)
    -   **ffreq**: flooding frequency class: 1 = once in two years; 2 = once in ten years; 3 = one in 50 years
    -   **landuse**: landuse classes
    -   **dist.m**: distance to the river (m)
    
  * `meuse.grid` is a R dataframe containing describing a grid covering the Meuse river (and the samples in the `meuse` dataframe). It contains the following variables:
    -   **x** and **y**: easting and northing (m) coordinates
    -   **dist**: distance to the river (normalized between 0 and 1)
    -   **soil**: soil characteristics (content of organic matter, type of soil, presence of lime)
    -   **ffreq**: flooding frequency class: 1 = once in two years; 2 = once in ten years; 3 = one in 50 years
    -   **part.a, part.b**: arbitrary division of the area in two areas, a and b

```{r }
library(sp,warn.conflicts = F) # load library
data(meuse) # load data
data(meuse.grid) # load target grid
```

We then add the log concentrations of metals to the `meuse` dataframe, thus creating four new variables: **log_cadmium**, **log_copper**, **log_lead**, **log_zinc**.

```{r }
var_names = c( "cadmium", "copper", "lead", "zinc")
logvar_names=paste0("log_",var_names)
for (i in 1:length(var_names)) {
  meuse[logvar_names[i]]=log(meuse[var_names[i]])
}
```

Plot the two dataframes

```{r loading_in_Db}

## Create Db containing the data from the `meuse` dataframe
obsDb=dfToDb(meuse,coordnames = c("x","y"))

# Plot the data
dbplot_point(obsDb,size="log_cadmium",sizeRange = c(0.1,3), pointColor = "red",
             xlab = "Easting (m)", ylab = "Northing (m)", title = "Log Concentration of Cadmium")

```



# Kriging using R

## Model of variogram

Before implementing a kriging predictor, we need to fix a variogram/covariance model for the variable we study (the log concentration of Cadmium). To do so, we fit on the data a variogram model using *gstlearn*.

1. With gstlearn, adjust an isotropic variogram model (impose an **exponential structure**) and extract its parameters (scale and sill). (*Hint: See Practical Session on Variography*)

```{r}

# Convert the `meuse` dataframe (which containins our observations) into a gstlearn Db object called obsDb
obsDb=dfToDb(meuse,coordnames = c("x","y"))

# Create an experimental omnidirectional variogram for the log concentration of Cadmium using the Db obsDb (-> `vario_exp`)
varioexp_iso = vario_exp(obsDb,vname="log_cadmium",nlag=20, dlag=100.)

# Fit a model with an exponential covariance on the experimental variogram (-> `model_fit`)
struct_names=c("EXPONENTIAL")
model_iso=model_fit(varioexp_iso,struct=struct_names)
# Display of the model
model_iso$display()

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_iso,model = model_iso,pairDisplay = "size",
           title="Model adjustment for log cadmium")

## Extract scale
Scale=model_getScales(model_iso)[1]

## Extract sill
Sill = model_getSills(model_iso)[1,1,1]

```

2. Implement a function to evaluate the covariance model for a given lag using the parameters previously extracted.

```{r}
## Covariance function
modelCov_exp <- function(h){
  # returns the value of exponential covariance at lag h
  Sill*exp(-(h/Scale))
}
```

## Simple kriging

We now implement the simple kriging estimate and the kriging error standard deviation (on a unique neighborhood) to predict the log concentration of Cadmium on the points defined in `meuse.grid`. 

1. Build a dataframe `obsData` containing the coordinates of the observations from the dataframe `meuse`, along with the measured log concentration of Cadmium. Similarly, Build a dataframe `targetData` containing the coordinates of the points in the dataframe `meuse.grid`. (*(Hint: The command `df[Vector_Of_Variable_Names])` extract from a dataframe `df` the variables specified in `Vector_Of_Variable_Names` and exports it as a new dataframe. And the command `df$Name_Of_A_Variable` extracts the variable `Name_Of_A_Variable` from the dataframe `df` and exports it as a vector.*)

```{r}
## Data matrix
obsData = meuse[c('x','y','log_cadmium')]
print(head(obsData))

## Target matrix
targetData = meuse.grid[c('x','y')]
print(head(targetData))

```

2. Compute the mean of the log concentration of Cadmium. (*(Hint: The command `df$Name_Of_A_Variable` extracts the variable `Name_Of_A_Variable` from a dataframe `df` and exports it as a vector.*)

```{r}
## Mean of observations
mean_log_cadmium = mean(obsData$log_cadmium)
mean_log_cadmium
```



3. Build the matrices of covariance values between pairs of data points and between data points and target points. 

```{r}

## Distance matrix between every pair of observation points
distObsObs = sqrt(outer(obsData$x, obsData$x, "-")^2 + outer(obsData$y, obsData$y, "-")^2)

## Corresponding covariance matrix
covObsObs  = modelCov_exp(distObsObs)

## Distance matrix between every pair  (observation point, target point)
distObsTarget = sqrt(outer(obsData$x, targetData$x, "-")^2 + outer(obsData$y, targetData$y, "-")^2)

## Corresponding covariance matrix
covObsTarget = modelCov_exp(distObsTarget)

```

4. Build the simple kriging prediction, on the points `targetData`, of the log concentration of Cadmium observed in `obsData`. In particular, use the mean of the log concentration of Cadmium as the known mean of the predictor. Then, compute the associated kriging standard-deviation.

```{r}
## Compute simple kriging weights
SKweights = solve(covObsObs, covObsTarget)

## Simple kriging estimate
SKestim = mean_log_cadmium + t(SKweights) %*% (obsData$log_cadmium - mean_log_cadmium)

## Kriging variance
SKvar = Sill - apply(SKweights * covObsTarget, 2, sum)
#SKvar=cov-diag(t(SKweights)%*%covTargetGrid) # equivalent to above but numerically less efficient

## Kriging standard deviation
SKsd = sqrt(SKvar)

#---------------------------------------------------

## Plot the results side by side

par(mfrow=c(1,2)) #<- To create an array of plots
# Plot of the kriging predictions using `quilt.plot` from the `fields` package
quilt.plot(targetData$x, targetData$y, SKestim, asp=1,main="Simple kriging predictions")
points(obsData$x,obsData$y,pch=19,cex=0.25)
# Plot of the kriging standard deviations using `quilt.plot` from the `fields` package
quilt.plot(targetData$x, targetData$y, SKsd, asp=1,main="Simple kriging std-dev")
points(obsData$x,obsData$y,pch=19,cex=0.25)
par(mfrow=c(1,1)) #<- To revert to a single plot

```


# Kriging using gstlearn

## Simple kriging and ordinary kriging (unique neighborhood)

We now show how to use *gstlearn* to compute kriging predictors. The first thing we need to do is to convert our R dataframe `meuse` and `meuse.grid` into *gstlearn* Db objects.

```{r}

## Create Db containing the data from the `meuse` dataframe (Already done before)
obsDb=dfToDb(meuse,coordnames = c("x","y"))
obsDb$display()

# Convert `meuse.grid` from R dataframe to gstlearn grid database (DbGrid)
targetDb = dfToDbGrid(meuse.grid,coordnames = c('x','y'))
targetDb$display()

# Plot the distance covariate (see universal kriging)
dbplot_grid(targetDb, color='dist')
dbplot_point(obsDb,size="log_cadmium",
             sizeRange = c(0.1,3), pointColor = "red",
             xlab = "Easting (m)", ylab = "Northing (m)",
             title='Plot data',
             add=TRUE)

```


1. Compute a simple kriging prediction on the points in `targetDb` using the data in `obsDb` and the model `model_iso` fitted in the previous section. Plot the results (prediction and standard deviation of kriging error) and compare them to the results obtained in the previous part (using `R` only). *(Hint: Use the function `minikriging`)*

```{r}
## Simple kriging using gstlearn
minikriging(obsDb, targetDb, vname = "log_cadmium", 
            model = model_iso, 
            type = "simple", mean = mean_log_cadmium,  prefix = "SK", 
            std = TRUE)


## Plot kriging estimate
dbplot_grid(targetDb, color='SK.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(targetDb, color='SK.log_cadmium.stdev',title='log cadmium prediction standard deviation')

```




1. Adjust an anisotropic variogram model (see TP_vario).

```{r}
# experimental variogram
varioexp_aniso = vario_exp(obsDb,vname="log_cadmium",dir=c(0,45,90,135),nlag=20, dlag=100.)

# fitting the model
model_aniso=model_fit(varioexp_aniso,struct=struct_names)
# display of the model
model_aniso$display() ## look at the anisotropic matrices

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_aniso,model = model_aniso,pairDisplay = "size",
           title="Model adjustment for cadmium")

```

2. Simple kriging: use model to compute the simple kriging predictor of the cadmium concentration, using the function `kriging`. Plot the results (prediction and standard deviation of kriging error) and compare them to the results obtained in the previous part (using `R` only).

```{r}
## Simple kriging using gstlearn
minikriging(obsDb, targetDb, vname = "log_cadmium", model = model_aniso, type = "simple", prefix = "SK", mean = mean_log_cadmium, neighborhood = "unique", std = TRUE)


## Plot kriging estimate
dbplot_grid(targetDb, color='SK.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(targetDb, color='SK.log_cadmium.stdev',title='log cadmium prediction standard deviation')

```

3. Ordinary kriging: use the same neighborhood and model to compute ordinary kriging estimate.

```{r}
minikriging(obsDb, targetDb, vname = "log_cadmium", model = model_aniso, type = "ordinary", prefix = "OK", neighborhood = "unique", std = TRUE)

## Plot kriging estimate
dbplot_grid(targetDb, color='OK.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(targetDb, color='OK.log_cadmium.stdev',title='log cadmium prediction standard deviation')

```

## Comparison of the results

1. Cross validation : For each observation location x_i, compute the kriging prediction at x_i when using all the observations except the one located at x_i. The cross-validation error at x_i is then defined as the difference between this prediction and the actual observed value at x_i.

Cross-validation is done by the gstlearn function xvalid. This function returns a db containing the same variables as the input db + two new variables: One variable (with name ending with .esterr) containing the cross-validation errors, and one variable (with name ending with .stderr) containing the cross-validation errors normalized by the kriging standard deviation.


```{r}

## Cross-validation for simple kriging

err = xvalidation(obsDb, vname = "log_cadmium", model=model_aniso, type = "simple",prefix ="SK", mean = mean_log_cadmium, neighborhood = "unique", std = TRUE)

plot_hist(obsDb,vname="*esterr*",nbin=30,color="blue",xlab="Estimation Errors", title="Cross-Validation")

## Print some statistics about the cross-validation errors
print(c("Mean cross-validation error:",mean(obsDb[,"*esterr*"], na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(obsDb[,"*esterr*"]^2, na.rm=TRUE)))
print(c("Mean squared standardized error:",mean(obsDb[,"*stderr*"]^2, na.rm=TRUE)))

dbplot_grid(targetDb,color = "SK*estim")
dbplot_point(obsDb,size = "*esterr*", add=T)

## Cross-validation for ordinary kriging

#...

```

2. Correlation plot: to compare the results of both estimator, you can also use the function `plot.correlation`. For example, plot the correlation between predictions on the one hand, and standard deviations of error on the second hand obtained with simple kriging (`SK`) and ordinary kriging (`OK`).

```{r}
## Correlation plot Simple Kriging VS Ordinary Kriging: Predictions

plot_correlation(targetDb,vnamex="OK.log_cadmium.estim",vnamey="SK.log_cadmium.estim", title="Estimation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")
                     
## Correlation plot Simple Kriging VS Ordinary Kriging: Standard deviations

plot_correlation(targetDb,vnamex="OK.log_cadmium.stdev",vnamey="SK.log_cadmium.stdev", title="Estimation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")

```

3. Split randomly the dataset into a training and a validation datasets. Compute the mean squared error at the validation locations.

## Kriging with moving neighborhood

Up until now, we only considered kriging with a unique neighborhood. To work with a moving neighborhood, we first need to define it by creating "neighborhood" object describing its characteristics. This is done using the `neighborhood` parameter of the 'kriging' funcion. We can specify:

* a neighborhood radius (argument `radius`, default=1.234e30): note that the default radius value is taken very large so that the neighborhood radius can basically be seen as infinite if the argument is not set by the user
* the minimum and maximum number of data points (within the specified radius) that should be included in the neighborhood (respectively through the arguments `nmini` and `nmaxi`): for a given target point, if the number of data points within the neighborhood radius is smaller that the specified minimum, then no prediction is performed at this target (it is set to undefined)

For instance, to design a small Moving Neighborhood with only 1 sample per neighborhood (irregardless of its distance to the target point), we use the following command:

```{r}
neigh = c(nmini=1, nmaxi=1, radius = 150)
```

2. Use that neighborhood and the anistropic model adjusted previously to compute ordinary kriging estimate and standard deviation of kriging error (set `prefix="OK_mov"`). Plot the results.

```{r}
## Ordinary kriging

minikriging(obsDb, targetDb, vname = "log_cadmium", model = model_aniso, type = "ordinary", prefix = "OK_mov",neighborhood = neigh, std = TRUE)

## Plot kriging estimate
dbplot_grid(targetDb, color='OK_mov.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(targetDb, color='OK_mov.log_cadmium.stdev',title='log cadmium prediction standard deviation')
```

3. Compare the results obtained with a unique neighborhood and a moving neighborhood (`OK` and `OK_mov`) with cross validation and correlation plot.

```{r}
## Cross-validation for Ordinary kriging with moving neigborhood

err = xvalidation(obsDb, vname = "log_cadmium", model=model_aniso, type = "ordinary", prefix="OK_mov", mean = mean_log_cadmium, neighborhood = "unique", std = TRUE)

plot_hist(obsDb,vname="Xvalid_OK_mov*esterr",nbin=30,color="blue",xlab="Estimation Errors", title="Cross-Validation")

## Print some statistics about the cross-validation errors
print(c("Mean cross-validation error:",mean(obsDb[,"Xvalid_OK_mov*esterr"], na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(obsDb[,"Xvalid_OK_mov*esterr"]^2, na.rm=TRUE)))
print(c("Mean squared standardized error:",mean(obsDb[,"Xvalid_OK_mov*stderr*"]^2, na.rm=TRUE)))

dbplot_grid(targetDb,color = "OK_mov*estim")
dbplot_point(obsDb,size = "Xvalid_OK_mov*esterr", add=T)

## Correlation plot Ordinary Kriging unique neigborhood VS moving neigborhood: Predictions

plot_correlation(targetDb,vnamex="OK.log_cadmium.estim",vnamey="OK_mov.log_cadmium.estim", title="Estimation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")
                     
## Correlation plot Simple Kriging VS Ordinary Kriging: Standard deviations

plot_correlation(targetDb,vnamex="OK.log_cadmium.stdev",vnamey="OK_mov.log_cadmium.stdev", title="Estimation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")

```

Bonus question: try with other neighborhoods and compare the results.

## Change of model

Change the models (impose other structures) and compare the performance of kriging estimates (be attentive to the changes in standard deviation of kriging error).

```{r}
## Define model

struct_names=c("NUGGET","EXPONENTIAL")
# fitting the model
model_aniso=model_fit(varioexp_aniso,struct=struct_names)
# display of the model
model_aniso$display() ## look at the anisotropic matrices

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_aniso,model = model_aniso,pairDisplay = "size",
           title="Model adjustment for cadmium")

## ....

```

# Multivariate geostatistics

## Multivariate variography

1. Variograms

Compute and plot the variograms and cross-variograms for the 4 heavy metal (log) concentration.

```{r Multivariate Modelling, fig.height=5,  fig.align='center'}

# Variable names
variable_names=paste0("log_", c("cadmium","copper","lead","zinc"))

# omni-directional variograms and cross variograms
vario_iso4var = vario_exp(obsDb,vname=variable_names,nlag=20, dlag=100.)
dev.new() # Open new window
plot_vario(vario_iso4var)

# directional variograms and cross variograms
vario_aniso4var = vario_exp(obsDb,vname=variable_names,dir=c(0,45,90,135),nlag=20, dlag=100.)
dev.new() # Open new window
plot_vario(vario_aniso4var)

## Auto-fit

struct_names = c("NUGGET","EXPONENTIAL")

# isotropic case
model_iso4var=model_fit(vario_iso4var,struct=struct_names)

# Display and plot
model_iso4var$display()
dev.new()
plot_vario(vario_iso4var, model_iso4var)


# selection of the variables
ivar = 1
jvar = 3


p1 = plot_vario(vario_iso4var, model_iso4var, ivar = ivar, jvar = ivar,
                title = paste0(variable_names[1+ivar], "-", variable_names[1+ivar]))
p2 = plot_vario(vario_iso4var, model_iso4var, ivar = ivar, jvar = jvar,
                title = paste0(variable_names[1+ivar], "-", variable_names[1+jvar]))
p3 = plot_vario(vario_iso4var, model_iso4var, ivar = jvar, jvar = jvar,
                title = paste0(variable_names[1+jvar], "-", variable_names[1+jvar]))

dev.new()
ggarrange(p1, p2, p3, ncol = 3, nrow = 1,legend = "bottom",common.legend = TRUE)

```

2. Compute the ordinary cokriging predictions with a unique neighborhood of the four heavy metals. 

```{r Cokriging, fig.height=6}

## Cokriging: Since cross-variograms are provided to the function, the kriging function will perform a cokriging 
## Note that gstlearn computes cokriging estimates for all the variables for which cross variograms are provided.

minikriging(obsDb, targetDb, vname = variable_names, model = model_iso4var, type = "ordinary", prefix = "COK", neighborhood = "unique", std = TRUE)

## Cokriging prediction of Cadmium
dbplot_grid(targetDb,color = 'COK.log_cadmium.estim',title='Cokriging of log cadmium concentration',colorLegendTitle="log concentration")

## Cokriging prediction of Copper
dbplot_grid(targetDb,color = 'COK.log_copper.estim',title='Cokriging of log copper concentration',colorLegendTitle="log concentration")

## Cokriging prediction of lead
dbplot_grid(targetDb,color = 'COK.log_lead.estim',title='Cokriging of log lead concentration',colorLegendTitle="log concentration")

## Cokriging prediction of zinc
dbplot_grid(targetDb,color = 'COK.log_zinc.estim',title='Cokriging of log zinc concentration',colorLegendTitle="log concentration")


## Cokriging standard deviation of Cadmium
dbplot_grid(targetDb,color = 'COK.log_cadmium.stdev',title='Cokriging standard deviation of log cadmium concentration',colorLegendTitle="log concentration")

## Cokriging standard deviation of Copper
dbplot_grid(targetDb,color = 'COK.log_copper.stdev',title='Cokriging standard deviation of log copper concentration',colorLegendTitle="log concentration")

## Cokriging standard deviation of lead
dbplot_grid(targetDb,color = 'COK.log_lead.stdev',title='Cokriging standard deviation of log lead concentration',colorLegendTitle="log concentration")

## Cokriging standard deviation of zinc
dbplot_grid(targetDb,color = 'COK.log_zinc.stdev',title='Cokriging standard deviation of log zinc concentration',colorLegendTitle="log concentration")

```

## Comparaison OK / CoKriging

3. Compare ordinary kriging and cokring results
```{r, fig.height=5, results="hide"}
## Correlation plot CoKriging VS Ordinary Kriging: Predictions

plot_correlation(targetDb,vnamex="OK.log_cadmium.estim",vnamey="COK.log_cadmium.estim", title="Estimation OK vs. COK", 
                    xlab="OK", ylab="COK")

## Correlation plot CoKriging VS Ordinary Kriging: Standard deviations
plot_correlation(targetDb,vnamex="OK.log_cadmium.stdev",vnamey="COK.log_cadmium.stdev", title="Standard deviation CoKriging vs. Ordinary", 
                    xlab="OK", ylab="COK")

```


