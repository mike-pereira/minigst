---
  title: "Kriging using (mini)gstlearn - Correction"
  author: "Emilie Chautru, Mike Pereira, and Thomas Romary"
  date: "Option Géostatistique 2024"
  output:
  pdf_document:
  number_sections: yes
  toc: yes
  editor_options: 
    chunk_output_type: console
  chunk_output_type: inline
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())

library(minigst)
```

# Preamble


```{r loading_gstlearn}
OptCst_defineByKey("ASP",0)
```


## Loading the Meuse dataset

We start by loading the data from the `sp` package. We load two data frames:

  * `meuse` is a R dataframe containing metal concentrations measured along the Meuse river in France. It contains the following variables:
    -   **x** and **y**: easting and northing (m) coordinates
    -   **cadmium**, **copper**, **lead**, **zinc**: topsoil heavy metal concentrations (ppm) (NB: obtained from composite samples **15m x 15m**)
    -   **elev**: relative elevation above the river (m)
    -   **dist**: distance to the river (normalized between 0 and 1)
    -   **om**, **soil**, **lime**: soil characteristics (content of organic matter, type of soil, presence of lime)
    -   **ffreq**: flooding frequency class: 1 = once in two years; 2 = once in ten years; 3 = one in 50 years
    -   **landuse**: landuse classes
    -   **dist.m**: distance to the river (m)
    
  * `meuse.grid` is a R dataframe containing describing a grid covering the Meuse river (and the samples in the `meuse` dataframe). It contains the following variables:
    -   **x** and **y**: easting and northing (m) coordinates
    -   **dist**: distance to the river (normalized between 0 and 1)
    -   **soil**: soil characteristics (content of organic matter, type of soil, presence of lime)
    -   **ffreq**: flooding frequency class: 1 = once in two years; 2 = once in ten years; 3 = one in 50 years
    -   **part.a, part.b**: arbitrary division of the area in two areas, a and b

```{r loading_data_set}
library(sp,warn.conflicts = F) # load library
data(meuse) # load data
data(meuse.grid) # load target grid
```


Create the data Db from the `meuse` dataframe

```{r loading_in_Db}

## Create Db from dataframe
data=dfToDb(meuse,coordnames = c("x","y"))

## Add log concentrations
var_name = c( "cadmium", "copper", "lead", "zinc")
addVarToDb(data,var=log(meuse[,var_name]),vname = paste0("log_",var_name))

# Plot the data
dbplot_point(data,size="log_cadmium",sizeRange = c(0.1,3), pointColor = "red",
             xlab = "Easting (m)", ylab = "Northing (m)", title = "Cadmium")

```

Create the target (grid) Db

```{r create the target (grid dB)}
target = dfToDbGrid(meuse.grid,coordnames = c('x','y'))

# Plot the distance covariate (see universal kriging)
dbplot_grid(target, color='dist',title='Distance to the river')

```

# Kriging using R

## Model of variogram

1. With gstlearn, adjust an isotropic variogram model (impose an **exponential structure**) and extract its parameters (scale and sill).

```{r}
# experimental variogram
varioexp_iso = vario_exp(data,vname="log_cadmium",nlag=20, dlag=100.)

# fitting the model with the selected basic structures
struct_names=c("EXPONENTIAL")
model_iso=model_fit(varioexp_iso,struct=struct_names)
# display of the model
model_iso$display()

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_iso,model = model_iso,pairDisplay = "size",
           title="Model adjustment for log cadmium")

## Extract scale (à warper ?)

Range = model_iso$getCova(0)$getRanges()[1]

## Extract sill

Sill = model_iso$getCova(0)$getSill(0,0)

```

2. Implement a function to evaluate the covariance model for a given lag using the parameters previsouly extracted.

```{r}
## Covariance function
modelCov_exp <- function(h,range,sill){
  # returns the value of exponential covariance at lag h
  sill*exp(-(h/range))
}
```

## Simple kriging

1. Implement the simple kriging estimate and the kriging error standard deviation (on a unique neighborhood) to estimate the concentration of cadmium on the points defined in `data`. 

a) Build a matrix containing the data (grid and concentration values) and compute the mean used for simple kriging.

```{r}
## Data matrix

DbCadmium = meuse[,1:3]
DbCadmium$cadmium = log(DbCadmium$cadmium)

DbCadmium

## Mean of observations

meanCadmium = mean(DbCadmium[,3])

meanCadmium

```

b) Build the matrices of covariance values between pairs of data points and between data points and target points. NB : the range extracted from the gstlearn adjustment is the practical range; the theoretical range is called "scale".

```{r}
## Convert Range into scale parameter

Range = Range/-log(.05)

## Distance matrix between every pair of observation points

distDbCadmium = sqrt(outer(DbCadmium$x, DbCadmium$x, "-")^2 + outer(DbCadmium$y, DbCadmium$y, "-")^2)

## Corresponding covariance matrix

covDbCadmium  = modelCov_exp(distDbCadmium, range = Range, sill = Sill)

## Distance matrix between every pair  (observation point, target point)

distTargetGrid = sqrt(outer(DbCadmium$x, meuse.grid$x, "-")^2 + outer(DbCadmium$y, meuse.grid$y, "-")^2)

## Corresponding covariance matrix

covTargetGrid = modelCov_exp(distTargetGrid, range = Range, sill = Sill)

```

c) Build the kriging estimates and compute the standard deviation of kriging error.

```{r}
## Compute simple kriging weights

SKweights = solve(covDbCadmium, covTargetGrid)

## Simple kriging estimate

SKestim = meanCadmium + t(SKweights) %*% (DbCadmium$cadmium - meanCadmium)

## Kriging variance
SKvar = Sill - apply(SKweights * covTargetGrid, 2, sum)
#SKvar=cov-diag(t(SKweights)%*%covTargetGrid) # equivalent to above but numerically less efficient

## Kriging standard deviation
SKsd = sqrt(SKvar)

```

2. Plot the maps of the estimated concentration and the standard deviation of kriging error. Use either the function `bubblePlot()` from the library `fields`.

```{r}
library(fields)

## Kriging plot using bubblePlot

bubblePlot(meuse.grid$x, meuse.grid$y, SKestim, asp=1)#, nx=length(unique(meuse.grid$x)), ny=length(meuse.grid$y))
points(DbCadmium$x,DbCadmium$y,pch=19,cex=0.25)


## Kriging stdev plot using bubblePlot
bubblePlot(meuse.grid$x, meuse.grid$y, SKsd, asp=1)
points(DbCadmium$x,DbCadmium$y,pch=19,cex=0.25)

```

# Kriging using gstlearn

## Simple kriging and ordinary kriging (unique neighborhood)

1. Adjust an anisotropic variogram model (see TP_vario).

```{r}
# experimental variogram
varioexp_aniso = vario_exp(data,vname="log_cadmium",dir=c(0,45,90,135),nlag=20, dlag=100.)

# fitting the model
model_aniso=model_fit(varioexp_aniso,struct=struct_names)
# display of the model
model_aniso$display() ## look at the anisotropic matrices

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_aniso,model = model_aniso,pairDisplay = "size",
           title="Model adjustment for cadmium")

```

2. Simple kriging: use model to compute the simple kriging predictor of the cadmium concentration, using the function `kriging`. Plot the results (prediction and standard deviation of kriging error) and compare them to the results obtained in the previous part (using `R` only).

```{r}
## Simple kriging using gstlearn

target = minikriging(data, target, vname = "log_cadmium", model = model_aniso, type = "simple", prefix = "SK", mean = meanCadmium, neighborhood = "unique", std = TRUE)


## Plot kriging estimate
dbplot_grid(target, color='SK.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(target, color='SK.log_cadmium.stdev',title='log cadmium prediction standard deviation')

```

3. Ordinary kriging: use the same neighborhood and model to compute ordinary kriging estimate.

```{r}
target = minikriging(data, target, vname = "log_cadmium", model = model_aniso, type = "ordinary", prefix = "OK", neighborhood = "unique", std = TRUE)

## Plot kriging estimate
dbplot_grid(target, color='OK.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(target, color='OK.log_cadmium.stdev',title='log cadmium prediction standard deviation')

```

## Comparison of the results

1. Cross validation : For each observation location x_i, compute the kriging prediction at x_i when using all the observations except the one located at x_i. The cross-validation error at x_i is then defined as the difference between this prediction and the actual observed value at x_i.

Cross-validation is done by the gstlearn function xvalid. This function returns a db containing the same variables as the input db + two new variables: One variable (with name ending with .esterr) containing the cross-validation errors, and one variable (with name ending with .stderr) containing the cross-validation errors normalized by the kriging standard deviation.


```{r}

## Cross-validation for simple kriging

err = xvalidation(data, vname = "log_cadmium", model=model_aniso, type = "simple",prefix ="SK", mean = meanCadmium, neighborhood = "unique", std = TRUE)

plot_hist(data,vname="*esterr*",nbin=30,color="blue",xlab="Estimation Errors", title="Cross-Validation")

## Print some statistics about the cross-validation errors
print(c("Mean cross-validation error:",mean(data[,"*esterr*"], na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(data[,"*esterr*"]^2, na.rm=TRUE)))
print(c("Mean squared standardized error:",mean(data[,"*stderr*"]^2, na.rm=TRUE)))

dbplot_grid(target,color = "SK*estim")
dbplot_point(data,size = "*esterr*", add=T)

## Cross-validation for ordinary kriging

#...

```

2. Correlation plot: to compare the results of both estimator, you can also use the function `plot.correlation`. For example, plot the correlation between predictions on the one hand, and standard deviations of error on the second hand obtained with simple kriging (`SK`) and ordinary kriging (`OK`).

```{r}
## Correlation plot Simple Kriging VS Ordinary Kriging: Predictions

plot_correlation(target,vnamex="OK.log_cadmium.estim",vnamey="SK.log_cadmium.estim", title="Estimation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")
                     
## Correlation plot Simple Kriging VS Ordinary Kriging: Standard deviations

plot_correlation(target,vnamex="OK.log_cadmium.stdev",vnamey="SK.log_cadmium.stdev", title="Estimation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")

```

3. Split randomly the dataset into a training and a validation datasets. Compute the mean squared error at the validation locations.

## Kriging with moving neighborhood

Up until now, we only considered kriging with a unique neighborhood. To work with a moving neighborhood, we first need to define it by creating "neighborhood" object describing its characteristics. This is done using the `neighborhood` parameter of the 'kriging' funcion. We can specify:

* a neighborhood radius (argument `radius`, default=1.234e30): note that the default radius value is taken very large so that the neighborhood radius can basically be seen as infinite if the argument is not set by the user
* the minimum and maximum number of data points (within the specified radius) that should be included in the neighborhood (respectively through the arguments `nmini` and `nmaxi`): for a given target point, if the number of data points within the neighborhood radius is smaller that the specified minimum, then no prediction is performed at this target (it is set to undefined)

For instance, to design a small Moving Neighborhood with only 1 sample per neighborhood (irregardless of its distance to the target point), we use the following command:

```{r}
neigh = c(nmini=1, nmaxi=1, radius = 150)
```

2. Use that neighborhood and the anistropic model adjusted previously to compute ordinary kriging estimate and standard deviation of kriging error (set `prefix="OK_mov"`). Plot the results.

```{r}
## Ordinary kriging

target = minikriging(data, target, vname = "log_cadmium", model = model_aniso, type = "ordinary", prefix = "OK_mov",neighborhood = neigh, std = TRUE)

## Plot kriging estimate
dbplot_grid(target, color='OK_mov.log_cadmium.estim',title='Predicted log cadmium concentration')

## Plot kriging stdev
dbplot_grid(target, color='OK_mov.log_cadmium.stdev',title='log cadmium prediction standard deviation')
```

3. Compare the results obtained with a unique neighborhood and a moving neighborhood (`OK` and `OK_mov`) with cross validation and correlation plot.

```{r}
## Cross-validation for Ordinary kriging with moving neigborhood

err = xvalidation(data, vname = "log_cadmium", model=model_aniso, type = "ordinary", prefix="OK_mov", mean = meanCadmium, neighborhood = "unique", std = TRUE)

plot_hist(data,vname="Xvalid_OK_mov*esterr",nbin=30,color="blue",xlab="Estimation Errors", title="Cross-Validation")

## Print some statistics about the cross-validation errors
print(c("Mean cross-validation error:",mean(data[,"Xvalid_OK_mov*esterr"], na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(data[,"Xvalid_OK_mov*esterr"]^2, na.rm=TRUE)))
print(c("Mean squared standardized error:",mean(data[,"Xvalid_OK_mov*stderr*"]^2, na.rm=TRUE)))

dbplot_grid(target,color = "OK_mov*estim")
dbplot_point(data,size = "Xvalid_OK_mov*esterr", add=T)

## Correlation plot Ordinary Kriging unique neigborhood VS moving neigborhood: Predictions

plot_correlation(target,vnamex="OK.log_cadmium.estim",vnamey="OK_mov.log_cadmium.estim", title="Estimation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")
                     
## Correlation plot Simple Kriging VS Ordinary Kriging: Standard deviations

plot_correlation(target,vnamex="OK.log_cadmium.stdev",vnamey="OK_mov.log_cadmium.stdev", title="Estimation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")

```

Bonus question: try with other neighborhoods and compare the results.

## Change of model

Change the models (impose other structures) and compare the performance of kriging estimates (be attentive to the changes in standard deviation of kriging error).

```{r}
## Define model

struct_names=c("NUGGET","EXPONENTIAL")
# fitting the model
model_aniso=model_fit(varioexp_aniso,struct=struct_names)
# display of the model
model_aniso$display() ## look at the anisotropic matrices

# plot of the experiment variogram and the fitted model
plot_vario(varioexp_aniso,model = model_aniso,pairDisplay = "size",
           title="Model adjustment for cadmium")

## ....

```

# Multivariate geostatistics

## Multivariate variography

1. Variograms

Compute and plot the variograms and cross-variograms for the 4 heavy metal (log) concentration.

```{r Multivariate Modelling, fig.height=5,  fig.align='center'}

# Variable names
variable_names=paste0("log_", c("cadmium","copper","lead","zinc"))

# omni-directional variograms and cross variograms
vario_iso4var = vario_exp(data,vname=variable_names,nlag=20, dlag=100.)
dev.new() # Open new window
plot_vario(vario_iso4var)

# directional variograms and cross variograms
vario_aniso4var = vario_exp(data,vname=variable_names,dir=c(0,45,90,135),nlag=20, dlag=100.)
dev.new() # Open new window
plot_vario(vario_aniso4var)

## Auto-fit

struct_names = c("NUGGET","EXPONENTIAL")

# isotropic case
model_iso4var=model_fit(vario_iso4var,struct=struct_names)

# Display and plot
model_iso4var$display()
dev.new()
plot_vario(vario_iso4var, model_iso4var)


# selection of the variables
ivar = 1
jvar = 3


p1 = plot_vario(vario_iso4var, model_iso4var, ivar = ivar, jvar = ivar,
                title = paste0(variable_names[1+ivar], "-", variable_names[1+ivar]))
p2 = plot_vario(vario_iso4var, model_iso4var, ivar = ivar, jvar = jvar,
                title = paste0(variable_names[1+ivar], "-", variable_names[1+jvar]))
p3 = plot_vario(vario_iso4var, model_iso4var, ivar = jvar, jvar = jvar,
                title = paste0(variable_names[1+jvar], "-", variable_names[1+jvar]))

dev.new()
ggarrange(p1, p2, p3, ncol = 3, nrow = 1,legend = "bottom",common.legend = TRUE)

```

2. Compute the ordinary cokriging predictions with a unique neighborhood of the four heavy metals. 

```{r Cokriging, fig.height=6}

## Cokriging: Since cross-variograms are provided to the function, the kriging function will perform a cokriging 
## Note that gstlearn computes cokriging estimates for all the variables for which cross variograms are provided.

target = minikriging(data, target, vname = variable_names, model = model_iso4var, type = "ordinary", prefix = "COK", neighborhood = "unique", std = TRUE)

## Cokriging prediction of Cadmium
dbplot_grid(target,color = 'COK.log_cadmium.estim',title='Cokriging of log cadmium concentration',colorLegendTitle="log concentration")

## Cokriging prediction of Copper
dbplot_grid(target,color = 'COK.log_copper.estim',title='Cokriging of log copper concentration',colorLegendTitle="log concentration")

## Cokriging prediction of lead
dbplot_grid(target,color = 'COK.log_lead.estim',title='Cokriging of log lead concentration',colorLegendTitle="log concentration")

## Cokriging prediction of zinc
dbplot_grid(target,color = 'COK.log_zinc.estim',title='Cokriging of log zinc concentration',colorLegendTitle="log concentration")


## Cokriging standard deviation of Cadmium
dbplot_grid(target,color = 'COK.log_cadmium.stdev',title='Cokriging standard deviation of log cadmium concentration',colorLegendTitle="log concentration")

## Cokriging standard deviation of Copper
dbplot_grid(target,color = 'COK.log_copper.stdev',title='Cokriging standard deviation of log copper concentration',colorLegendTitle="log concentration")

## Cokriging standard deviation of lead
dbplot_grid(target,color = 'COK.log_lead.stdev',title='Cokriging standard deviation of log lead concentration',colorLegendTitle="log concentration")

## Cokriging standard deviation of zinc
dbplot_grid(target,color = 'COK.log_zinc.stdev',title='Cokriging standard deviation of log zinc concentration',colorLegendTitle="log concentration")

```

## Comparaison OK / CoKriging

3. Compare ordinary kriging and cokring results
```{r, fig.height=5, results="hide"}
## Correlation plot CoKriging VS Ordinary Kriging: Predictions

plot_correlation(target,vnamex="OK.log_cadmium.estim",vnamey="COK.log_cadmium.estim", title="Estimation OK vs. COK", 
                    xlab="OK", ylab="COK")

## Correlation plot CoKriging VS Ordinary Kriging: Standard deviations
plot_correlation(target,vnamex="OK.log_cadmium.stdev",vnamey="COK.log_cadmium.stdev", title="Standard deviation CoKriging vs. Ordinary", 
                    xlab="OK", ylab="COK")

```


