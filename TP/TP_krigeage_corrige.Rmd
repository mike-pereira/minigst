---
title: "Kriging and cokriging using R/gstlearn"
author: "Grégoire Jacquemin"
date: "Option Géostatistique et Probabilités Appliquées - 04-10-2023"
output: 
    pdf_document:
        number_sections: true
        toc: true
---    

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,eval=TRUE, warning=FALSE)#,include = FALSE,fig.align='center')
```

# Preamble

1. Load the Meuse dataset and build a gstlearn database called `dBMeuse` with cadmium concentration as the only active regionalized variable. Recall that, for convenience, we work with the **logarithms of the concentrations**.

```{r}
## Clean environment and load packages

rm(list=ls())
library(sp)
library(gstlearn)
library(ggplot2)


## Load data

data(meuse)

# Create an empty Db

DbMeuse = Db()

# And import all columns in one a loop using [] operator

for (i in 1:6){
  field = names(meuse)[i]
  if(i < 3) {DbMeuse[field] = meuse[field]}
  else {DbMeuse[field] = log(1+meuse[field])}
}

DbMeuse$display()

# The locators are used to specify the **role** assigned to a Column for the rest of the study (unless they are modified).
# The locator is characterized by its name (`Z` for a variable and `X` for a coordinate) within the Enumeration `ELoc`.

DbMeuse$setLocators(c("x", "y"), ELoc_X())
DbMeuse$setLocator("cadmium", ELoc_Z(), cleanSameLocator=TRUE)

# Plot the data

p = ggDefaultGeographic()
p = p + plot.point(DbMeuse, name_color="cadmium", show.legend.symbol = TRUE,
                   legend.name.color="Concentration")
p = p + plot.decoration(title="Cadmium concentration", xlab="Easting", ylab="Northing")
ggPrint(p)
```

2. Load the target grid `meuse.grid` from the package *sp* and create a target DB (in a database called `DbMeuseGrid`) using the code below.

```{r,include=TRUE}
## Load grid

data('meuse.grid')


## Put it in a point db and give names to coordinates

#Create an empty Db

db = Db() 

# And import all columns in one a loop using [] operator

for (field in names(meuse.grid)){ 
  db[field] = meuse.grid[field]
}

db$setLocators(c("x","y"), ELoc_X())


## Create a grid that covers the points

DbMeuseGrid = DbGrid_createCoveringDb(db,dx = c(40, 40))

## Migrate from points to grid

res = migrateMulti(dbin=db, dbout = DbMeuseGrid, name = names(db[])[3:7], namconv=NamingConvention())

## Add selection on points for which the distance to the river is known

res = DbMeuseGrid$addSelection(tab = !is.na(DbMeuseGrid["dist"]), name = "Sel")

## Add a locator to the variable giving the distance to the river

DbMeuseGrid$setLocator("dist",ELoc_Z(),cleanSameLocator = T)

## Plot

ggplot() + plot(DbMeuseGrid,palette="Spectral")

```

# Kriging using R

## Model of variogram

1. With gstlearn, adjust an isotropic variogram model (impose an **exponential structure**) and extract its parameters (scale and sill).

The experimental (isotropic) variogram $\gamma$ is a  function defined as

$$\gamma(h)=\frac{1}{2\vert N(h)\vert}\sum_{(i,j) \in N(h)}\big\vert z(x_i)-z(x_j)\big\vert^2, \quad h\ge 0,$$
where $N(h)$ is set of all pairs of data points separated by a distance $h$ (called *lag*):
$$ N(h) = \bigg\lbrace (i,j) : \Vert x_j-x_i\Vert = h\bigg\rbrace_{1\le i\le j\le n},$$
and $\vert N(h)\vert$ is the cardinal of $N(h)$. In practice, when computing $\gamma(h)$, we look for pairs of data points separated by a distance $h \pm \tau h$ where $\tau > 0$ is a tolerance on the separation distance $h$. In other words, $N(h)$ is replaced by
$$ \widehat N(h) = \bigg\lbrace (i,j) : (1-\tau)h \le \Vert x_j-x_i\Vert \le (1+\tau) h\bigg\rbrace_{1\le i\le j\le n}$$
To compute an experimental variogram, we start by creating a `VarioParam` object containing the parameters of the variogram. This is done using the function `VarioParam_createOmniDirection`. We can specify the number of lags $h$ for which the experimental variogram is computed (argument `npas`), and the distance between these lags (argument `dpas`), as well as the tolerance $\tau$ on the lags (argument `toldis`).

Then, the experimental variogram is computed in two steps. First, a `Vario` object is initialized from the `VarioParam` object  and the `Db` containing the data points. Then, the values of the experimental variogram at the lags specified by  the `VarioParam` object  are computed using the method `compute` of the `Vario` object (which returns an error code, `0` meaning that no error was detected).

```{r}
## Compute experimental variogram

varioParamOmni = VarioParam_createOmniDirection(npas=20, dpas=100,toldis = 0.1)
varioexp = Vario(varioParamOmni, DbMeuse)
err = varioexp$compute()

varioexp

ggplot() + plot.varmod(varioexp)


## Auto-fit

fitmod = Model()
types = ECov_fromKeys(c("EXPONENTIAL"))
err = fitmod$fit(varioexp,types=types)

ggplot() + plot.varmod(varioexp, fitmod)

## Extract scale

Range = fitmod$getCova(0)$getRanges()[1]

## Extract sill

Sill = fitmod$getCova(0)$getSill(0,0)

```

2. Implement a function to evaluate the covariance model for a given lag using the parameters previsouly extracted.

```{r}
## Covariance function
modelCov <- function(h,range,sill){
  # returns the value of exponential covariance at lag h
  sill*exp(-(h/range))
}
```

## Simple kriging

1. Implement the simple kriging estimate and the kriging error standard deviation (on a unique neighborhood) to estimate the concentration of cadmium on the points defined in `DbMeuseGrid`. 

a) Build a matrix containing the data (grid and concentration values) and compute the mean used for simple kriging.

```{r}
## Data matrix

DbCadmium = DbMeuse[,1:3]

DbCadmium

## Mean of observations

meanCadmium = mean(DbCadmium[,3])

meanCadmium

```

b) Build the matrices of covariance values between pairs of data points and between data points and target points. NB : the range extracted from the gstlearn adjustment is the practical range; the theoretical range is called "scale".

```{r}
## Distance matrix between every pair of observation points

distDbCadmium = sqrt(outer(DbCadmium$x, DbCadmium$x, "-")^2 + outer(DbCadmium$y, DbCadmium$y, "-")^2)

## Corresponding covariance matrix

covDbCadmium  = modelCov(distDbCadmium, range = Range, sill = Sill)

## Distance matrix between every pair  (observation point, target point)

distTargetGrid = sqrt(outer(DbCadmium$x, DbMeuseGrid[, 1], "-")^2 + outer(DbCadmium$y, DbMeuseGrid[, 2], "-")^2)

## Corresponding covariance matrix

covTargetGrid = modelCov(distTargetGrid, range = Range, sill = Sill)

```

c) Build the kriging estimates and compute the standard deviation of kriging error.

```{r}
## Compute simple kriging weights

SKweights = solve(covDbCadmium, covTargetGrid)

## Simple kriging estimate

SKestim = meanCadmium + t(SKweights) %*% (DbMeuse["cadmium"] - meanCadmium)

## Kriging variance
SKvar = Sill - apply(SKweights * covTargetGrid, 2, sum)
# SKvar=C-diag(t(SKweights)%*%covTar) # equivalent to above

## Kriging standard deviation
SKsd = sqrt(SKvar)

```

2. Plot the maps of the estimated concentration and the standard deviation of kriging error. Use either the function `quilt.plot()` from the library `fields` (the dimension of the grid db `DbMeuseGrid` can be obtained using `length(unique(DbMeuseGrid["x1"]))`).

```{r}
library(fields)

## Kriging plot using quilt.plot
quilt.plot(DbMeuseGrid["x1"], DbMeuseGrid["x2"], SKestim[, 1], asp=1, nx=length(unique(DbMeuseGrid["x1"])), ny=length(unique(DbMeuseGrid["x2"])))
points(DbMeuse["x"],DbMeuse["y"],pch=19,cex=0.25)

## Kriging stdev plot using quilt.plot
quilt.plot(DbMeuseGrid["x1"], DbMeuseGrid["x2"], SKsd ,asp=1, nx=length(unique(DbMeuseGrid["x1"])), ny=length(unique(DbMeuseGrid["x2"])))
points(DbMeuse["x"],DbMeuse["y"],pch=19,cex=0.25)

```

# Kriging using gstlearn

## Simple kriging and ordinary kriging (unique neighborhood)

1. Create a unique neighborhood using the function `NeighUnique` and adjust an anisotropic variogram model.

```{r}
## Create unique neighborhood

uniqueNeigh = NeighUnique()


## Experiemental variogram

varioParamMulti = VarioParam_createMultiple(ndir = 4, npas = 20, dpas = 100)
varioexpMulti = Vario(varioParamMulti, DbMeuse)
err = varioexpMulti$compute()


## Auto-fit

fitmod = Model()
types = ECov_fromKeys(c("EXPONENTIAL"))
err = fitmod$fit(varioexpMulti,types=types)

ggplot() + plot.varmod(varioexpMulti, fitmod)

```

2. Simple kriging: use the neighborhood and model to compute the simple kriging estimate of the cadmium concentration, using the function `kriging`. You should set `namconv=NamingConvention("SK")` to spot the results (and not mix them with the results obtained later on). Plot the results (estimation and standard deviation of kriging error) and compare them to the results obtained in the previous part (using `R` only).

```{r}
## Simple kriging using gstlearn

err = kriging(dbin=DbMeuse, dbout=DbMeuseGrid, model=fitmod, 
              neigh=uniqueNeigh,
              flag_est=TRUE, flag_std=TRUE, flag_varz=FALSE,
              namconv=NamingConvention("SK")
              )


## Plot kriging estimate
p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,
                  show.legend.raster = TRUE, palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1.5)
p = p + plot.decoration(title="Simple Kriging over whole Grid")
ggPrint(p)

## Plot kriging stdev
p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster="SK.cadmium.stdev",
                  show.legend.raster = TRUE, palette="Spectral",legend.name.raster="Standard deviation")
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1.5)
p = p + plot.decoration(title="Simple Kriging std-dev over whole Grid")
ggPrint(p)

```

3. Ordinary kriging: use the same neighborhood and model to compute ordinary kriging estimate. You should set `namconv=NamingConvention("OK")`. Plot the results.

```{r}
## Ordinary kriging using gstlearn

fitmodOK = fitmod$clone()
err = fitmodOK$addDrift(Drift1())

err = kriging(dbin=DbMeuse, dbout=DbMeuseGrid, model=fitmodOK, 
              neigh=uniqueNeigh,
              flag_est=TRUE, flag_std=TRUE, flag_varz=FALSE,
              namconv=NamingConvention("OK")
              )


## Plot kriging estimate

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,
                  show.legend.raster = TRUE, palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1.5)
p = p + plot.decoration(title="Ordinary Kriging over whole Grid")
ggPrint(p)

## Plot kriging stdev

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster="OK.cadmium.stdev",
                  show.legend.raster = TRUE, palette="Spectral",legend.name.raster="Standard deviation")
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1.5)
p = p + plot.decoration(title="Ordinary Kriging std-dev over whole Grid")
ggPrint(p)

```

## Comparison of the results

1. Cross validation : For each observation location x_i, compute the kriging prediction at x_i when using all the observations except the one located at x_i. The cross-validation error at x_i is then defined as the difference between this prediction and the actual observed value at x_i.

Cross-validation is done by the gstlearn function xvalid. This function returns a db containing the same variables as the input db + two new variables: One variable (with name ending with .esterr) containing the cross-validation errors, and a one variable (with name ending with .stderr) containing the cross-validation errors normalized by the kriging standard deviation.


```{r}

## Cross-validation for simple kriging

err = xvalid(db=DbMeuse, model=fitmod, neigh=uniqueNeigh, 
             flag_xvalid_est=1, flag_xvalid_std=1,  
             namconv=NamingConvention_create("Xvalid", flag_locator = FALSE)
            )


p = ggplot()
p = p + plot.hist(DbMeuse,name="*esterr*",bins=30,fill="blue")
p = p + plot.decoration(xlab="Estimation Errors", title="Cross-Validation")
ggPrint(p)


p = ggplot()
p = p + plot.hist(DbMeuse,name="*stderr*",bins=30,fill="blue")
p = p + plot.decoration(xlab="Standardized Errors", title="Cross-Validation")
ggPrint(p)


## Print some statistics about the cross-validation errors

print(c("Mean cross-validation error:",mean(DbMeuse$getColumn("*esterr*"), na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(DbMeuse$getColumn("*esterr*")^2, na.rm=TRUE)))
print(c("Mean standardized error:",mean(DbMeuse$getColumn("*stderr*")^2, na.rm=TRUE)))


p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid)
p = p + plot.point(DbMeuse,name_size = "*esterr", sizmax=3, flagAbsSize = TRUE)
p = p + plot.decoration(title = "Cross-Validation scores")
ggPrint(p)


## Cross-validation for ordinary kriging

#...

```

2. Correlation plot: to compare the results of both estimator, you could also use the function `plot.correlation`. For example, plot the correlation between predictions on the one hand, and standard deviations of error on the second hand obtained with simple kriging (`SK`) and ordinary kriging (`OK`).

```{r}
## Correlation plot Simple Kriging VS Ordinary Kriging: Predictions

p = ggplot()
p = p + plot.correlation(DbMeuseGrid,name1="OK.cadmium.estim",name2="SK.cadmium.estim", 
                     flagRegr=TRUE, flagSameAxes=TRUE, bins=100)
p = p + plot.decoration(title="Estimation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")
ggPrint(p)


## Correlation plot Simple Kriging VS Ordinary Kriging: Standard deviations

p = ggplot()
p = p + plot.correlation(DbMeuseGrid,name1="OK.cadmium.stdev",name2="SK.cadmium.stdev", 
                     flagRegr=TRUE, flagSameAxes=TRUE, bins=100)
p = p + plot.decoration(title="Standard deviation Simple vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="Simple Kriging")
ggPrint(p)

```

3. Split randomly the dataset into a training and a validation datasets. Compute the mean squared error at the validation locations.

## Kriging with moving neighborhood

Up until now, we only considered kriging with a unique neighborhood. To work with a moving neighborhood, we first need to define it by creating "neighborhood" object describing its characteristics. This is done using the `NeighMoving_create` function. We can specify:

* a neighborhood radius (argument `radius`, default=1.234e30): note that the default radius value is taken very large so that the neighborhood radius can basically be seen as infinite if the argument is not set by the user
* the minimum and maximum number of data points (within the specified radius) that should be included in the neighborhood (respectively through the arguments `nmini` and `nmaxi`): for a given target point, if the number of data points within the neighborhood radius is smaller that the specified minimum, then no prediction is performed at this target (it is set to undefined)

For instance, to design a small Moving Neighborhood with only 1 sample per neighborhood (irregardless of its distance to the target point), we use the following command:

```{r}
smallNeigh = NeighMoving_create(nmini=1, nmaxi=1)
```

1. Build a moving neighborhood using the function `NeighMoving_create`.

```{r}
## Create moving neighborhood

movingNeigh = NeighMoving_create(nmini=1, nmaxi=10, radius=150)

```

2. Use that neighborhood and the anistropic model adjusted previously to compute ordinary kriging estimate and standard deviation of kriging error (set `namconv=NamingConvention("OK_mov")`). Plot the results.

```{r}
## Ordinary kriging

err = kriging(dbin=DbMeuse, dbout=DbMeuseGrid, model=fitmodOK, 
              neigh=movingNeigh,
              flag_est=TRUE, flag_std=TRUE, flag_varz=FALSE,
              namconv=NamingConvention("OK_mov")
              )

# Plot kriging estimate

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster="OK_mov.cadmium.estim",
                  show.legend.raster = TRUE, palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1.5)
p = p + plot.decoration(title="Ordinary Kriging over whole Grid")
ggPrint(p)

## Plot kriging stdev

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster="OK_mov.cadmium.stdev",
                  show.legend.raster = TRUE, palette="Spectral",legend.name.raster="Standard deviation")
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1.5)
p = p + plot.decoration(title="Ordinary Kriging std-dev over whole Grid")
ggPrint(p)
```

3. Compare the results obtained with a unique neighborhood and a moving neighborhood (`OK` and `OK_mov`) with cross validation and correlation plot.

```{r}
## Cross-validation for Ordinary kriging with moving neigborhood

err = xvalid(db=DbMeuse, model=fitmod, neigh=movingNeigh, 
             flag_xvalid_est=1, flag_xvalid_std=1,  
             namconv=NamingConvention_create("Xvalid_mov", flag_locator = FALSE)
            )

DbMeuse

p = ggplot()
p = p + plot.hist(DbMeuse, name="Xvalid_mov.cadmium.esterr",bins=30,fill="blue")
p = p + plot.decoration(xlab="Estimation Errors", title="Cross-Validation")
ggPrint(p)


p = ggplot()
p = p + plot.hist(DbMeuse,name="Xvalid_mov*stderr",bins=30,fill="blue")
p = p + plot.decoration(xlab="Standardized Errors", title="Cross-Validation")
ggPrint(p)


## Print some statistics about the cross-validation errors

print(c("Mean cross-validation error:",mean(DbMeuse$getColumn("Xvalid_mov*esterr"), na.rm=TRUE)))
print(c("Mean squared cross-validation error:",mean(DbMeuse$getColumn("Xvalid_mov*esterr")^2, na.rm=TRUE)))
print(c("Mean standardized error:",mean(DbMeuse$getColumn("Xvalid_mov*stderr")^2, na.rm=TRUE)))


p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid)
p = p + plot.point(DbMeuse,name_size = "Xvalid_mov*esterr", sizmax=3, flagAbsSize = TRUE)
p = p + plot.decoration(title = "Cross-Validation scores")
ggPrint(p)



## Correlation plot Ordinary Kriging unique neigborhood VS moving neigborhood: Predictions

p = ggplot()
p = p + plot.correlation(DbMeuseGrid,name1="OK.cadmium.estim",name2="OK_mov.cadmium.estim", 
                     flagRegr=TRUE, flagSameAxes=TRUE, bins=100)
p = p + plot.decoration(title="Estimation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")
ggPrint(p)


## Correlation plot Ordinary Kriging unique neigborhood VS moving neigborhood: Standard deviations

p = ggplot()
p = p + plot.correlation(DbMeuseGrid,name1="OK.cadmium.stdev",name2="OK_mov.cadmium.stdev", 
                     flagRegr=TRUE, flagSameAxes=TRUE, bins=100)
p = p + plot.decoration(title="Standard deviation unique vs. moving", 
                    xlab="unique neigh", ylab="moving neigh")
ggPrint(p)

```

Bonus question: try with other neighborhoods and compare the results.

## Change of model

Change the models (impose other structures) and compare the performance of kriging estimates (be attentive to the changes in standard deviation of kriging error).

```{r}
## Define model

fitmod2 = Model()
types = ECov_fromKeys(c("NUGGET", "SPHERICAL"))
err = fitmod2$fit(varioexp,types=types)

ggplot() + plot.varmod(varioexp, fitmod2)

## ....

```

# Multivariate geostatistics

## Multivariate variography

1. Variograms

Compute and plot the variograms and cross-variograms for the 4 heavy metal (log) concentration.

```{r Multivariate Modelling, fig.height=5,  fig.align='center'}

library(ggpubr)

## Put locators on variables of interest

DbMeuse$setLocators(c("cadmium", "copper", "lead", "zinc"), ELoc_Z())


## Experimental variogram
varioParamMulti = VarioParam_createMultiple(ndir = 4, npas = 20, dpas = 100)

varioexpMulti4var = Vario(varioParamMulti, DbMeuse)

err = varioexpMulti4var$compute()

# We can then plot the experimental variograms and cross-variograms with a simple command:
# the plot in the i-th row and j-th column corresponds to the cross-variogram between the variables with locators `zi` and `zj` (hence the diagonal plots correspond to the variograms of each variable).

multi.varmod(varioexpMulti4var)


## Auto-fit

fitmodMulti = Model()

types = ECov_fromKeys(c("EXPONENTIAL"))

err = fitmodMulti$fit(varioexpMulti4var, types=types)

multi.varmod(varioexpMulti4var, fitmodMulti)

```

2. Compute the cokriging predictions of the four heavy metals. 

```{r Cokriging, fig.height=6}
## Unique neighborhood
uniqueNeigh = NeighUnique()

## Cokriging: Since cross-variograms are provided to the function, the kriging function will perform a cokriging 
## Note that gstlearn computes cokriging estimates for all the variables for which cross variograms are provided.

err = kriging(dbin=DbMeuse, dbout=DbMeuseGrid, model=fitmodMulti, 
              neigh=uniqueNeigh,
              namconv=NamingConvention_create(prefix="COK"))

## Cokriging prediction of Cadmium

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.cadmium*estim",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Cadmium - CoKriging")
ggPrint(p)


## Cokriging prediction of Copper

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.copper*estim",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Copper - CoKriging")
ggPrint(p)

## Cokriging prediction of Lead

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.lead*estim",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Lead - CoKriging")
ggPrint(p)

## Cokriging prediction of Zinc

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.zinc*estim",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Zinc - CoKriging")
ggPrint(p)


## Cokriging standard deviations of Cadmium

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.cadmium*stdev",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Cokriging standard deviations of Cadmium")
ggPrint(p)

## Cokriging standard deviations of Copper

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.copper*stdev",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Cokriging standard deviations of Copper")
ggPrint(p)

## Cokriging standard deviations of Lead

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.lead*stdev",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Cokriging standard deviations of Lead")
ggPrint(p)

## Cokriging standard deviations of Zinc

p = ggDefaultGeographic()
p = p + plot.grid(DbMeuseGrid,name_raster = "COK.zinc*stdev",
                  show.legend.raster = TRUE, 
                  palette="Spectral",legend.name.raster="Concentration") 
p = p + plot.point(DbMeuse,flagCst = T,pch=18,cex=1)
p = p + plot.decoration(title="Cokriging standard deviations of Zinc")
ggPrint(p)

```

## Comparaison OK / CoKriging

3. Compare ordinary kriging and cokring results
```{r, fig.height=5, results="hide"}
## Correlation plot CoKriging VS Ordinary Kriging: Predictions

p = ggplot()
p = p + plot.correlation(DbMeuseGrid,name1="OK.cadmium.estim",name2="COK.cadmium.estim", 
                     flagRegr=TRUE, flagSameAxes=TRUE, bins=100)
p = p + plot.decoration(title="Estimation CoKriging vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="CoKriging")
ggPrint(p)


## Correlation plot CoKriging VS Ordinary Kriging: Standard deviations

p = ggplot()
p = p + plot.correlation(DbMeuseGrid,name1="OK.cadmium.stdev",name2="COK.cadmium.stdev", 
                     flagRegr=TRUE, flagSameAxes=TRUE, bins=100)
p = p + plot.decoration(title="Standard deviation CoKriging vs. Ordinary", 
                    xlab="Ordinary Kriging", ylab="CoKriging")
ggPrint(p)
```
